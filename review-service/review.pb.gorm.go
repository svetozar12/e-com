package review_service

import (
	context "context"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type ReviewORM struct {
	Array     pq.StringArray
	Array2    pq.StringArray
	Comment   string
	ProductId int32
	Rating    int32
	ReviewId  int32
	Timestamp *time.Time
	UserId    int32
}

// TableName overrides the default tablename generated by GORM
func (ReviewORM) TableName() string {
	return "review"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Review) ToORM(ctx context.Context) (ReviewORM, error) {
	to := ReviewORM{}
	var err error
	if prehook, ok := interface{}(m).(ReviewWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ReviewId = m.ReviewId
	to.ProductId = m.ProductId
	to.UserId = m.UserId
	to.Comment = m.Comment
	to.Rating = m.Rating
	if m.Timestamp != nil {
		t := m.Timestamp.AsTime()
		to.Timestamp = &t
	}
	if posthook, ok := interface{}(m).(ReviewWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReviewORM) ToPB(ctx context.Context) (Review, error) {
	to := Review{}
	var err error
	if prehook, ok := interface{}(m).(ReviewWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ReviewId = m.ReviewId
	to.ProductId = m.ProductId
	to.UserId = m.UserId
	to.Comment = m.Comment
	to.Rating = m.Rating
	if m.Timestamp != nil {
		to.Timestamp = timestamppb.New(*m.Timestamp)
	}
	if posthook, ok := interface{}(m).(ReviewWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Review the arg will be the target, the caller the one being converted from

// ReviewBeforeToORM called before default ToORM code
type ReviewWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReviewORM) error
}

// ReviewAfterToORM called after default ToORM code
type ReviewWithAfterToORM interface {
	AfterToORM(context.Context, *ReviewORM) error
}

// ReviewBeforeToPB called before default ToPB code
type ReviewWithBeforeToPB interface {
	BeforeToPB(context.Context, *Review) error
}

// ReviewAfterToPB called after default ToPB code
type ReviewWithAfterToPB interface {
	AfterToPB(context.Context, *Review) error
}

// DefaultCreateReview executes a basic gorm create call
func DefaultCreateReview(ctx context.Context, in *Review, db *gorm.DB) (*Review, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReviewORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskReview patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReview(ctx context.Context, patchee *Review, patcher *Review, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Review, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTimestamp bool
	for i, f := range updateMask.Paths {
		if f == prefix+"ReviewId" {
			patchee.ReviewId = patcher.ReviewId
			continue
		}
		if f == prefix+"ProductId" {
			patchee.ProductId = patcher.ProductId
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"Rating" {
			patchee.Rating = patcher.Rating
			continue
		}
		if !updatedTimestamp && strings.HasPrefix(f, prefix+"Timestamp.") {
			if patcher.Timestamp == nil {
				patchee.Timestamp = nil
				continue
			}
			if patchee.Timestamp == nil {
				patchee.Timestamp = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Timestamp."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Timestamp, patchee.Timestamp, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Timestamp" {
			updatedTimestamp = true
			patchee.Timestamp = patcher.Timestamp
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReview executes a gorm list call
func DefaultListReview(ctx context.Context, db *gorm.DB) ([]*Review, error) {
	in := Review{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ReviewORM{}, &Review{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []ReviewORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReviewORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Review{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReviewORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReviewORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReviewORM) error
}
